package database

import (
	"database/sql"
	"errors"
)

// Database defines a generic interface that wraps an *sql.DB connection and a user-defined queries implementation.
//
// Queries represents the type-safe query methods generated by tools like sqlc or hand-written wrappers.
type Database[Queries any] interface {
	// DB returns the underlying *sql.DB instance.
	DB() *sql.DB

	// Queries returns the user-defined, type-safe query methods.
	Queries() Queries
}

type database[Queries any] struct {
	db      *sql.DB
	queries Queries
}

// NewDatabase returns an initialised database containing the underlying sql connection and user-definied queries.
func NewDatabase[DB any, Queries any](dsn, driver string, constructor func(DB) Queries) (Database[Queries], error) {
	if dsn == "" {
		return nil, errors.New("dsn cannot be blank")
	}
	if driver == "" {
		return nil, errors.New("driver cannot be blank")
	}
	if constructor == nil {
		return nil, errors.New("constructor cannot be nil")
	}

	db, err := sql.Open(driver, dsn)
	if err != nil {
		return nil, err
	}

	return &database[Queries]{
		db:      db,
		queries: constructor(any(db).(DB)),
	}, nil
}

// DB returns access to the underlying *sql.DB connection.
func (d *database[Queries]) DB() *sql.DB { return d.db }

// Queries returns access to the underlying user-defined queries.
func (d *database[Queries]) Queries() Queries { return d.queries }
