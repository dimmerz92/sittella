# Sittella

Sittella is a.. well, I guess a micro framework?

It came about after I spent far too long trying to figure out how to structure a Go SSR webapp.

I took inspiration from the way other HTTP frameworks (i.e., Echo) have a central context that makes it nice and ergonomic to do most of what I needed. However, I felt it needed a little extra. I wanted to have access to my database, auth store, session store, and other useful things on my context.

Presenting Sittella!

## Features

- Central http request scoped context (similar to echo)
- Context provides access to a database, session store, auth store, and emailer
- Simple routing methods on the Application (GET, POST, PUT, etc.)
- Helpful methods on the context for common responses (HTML, JSON, etc.)
- Integrated [templ](https://github.com/a-h/templ) rendering method
- HTMX aware redirect and check method
- Fully customisable through interfaces

## Quick Start

```go
package main

import (
	"context"
	"database/sql"
	"fmt"
	"net/http"

	"github.com/dimmerz92/sittella"
	"github.com/dimmerz92/sittella/auth"
	"github.com/dimmerz92/sittella/database"
	"github.com/dimmerz92/sittella/mailer"
	"github.com/dimmerz92/sittella/sessions"
	_ "github.com/mattn/go-sqlite3"
	"github.com/wneessen/go-mail"
)

// Queries would be something like the *Queries generated by sqlc or your own custom queries.
type Queries struct{}

// constructor would be something like the New func generated by sqlc or your own custom function.
func constructor(db *sql.DB) *Queries { return &Queries{} }

func main() {
	// create the database
	db, err := database.NewDatabase(":memory:", "sqlite3", constructor)
	if err != nil {
		panic(err)
	}

	// configure an instantiate the app
	app := sittella.New(sittella.Config[*Queries]{
		Database: db,
		Mailer: &mailer.DefaultMailer{
			Host: "smtp.example.com",
			From: "hello@example.com",
			Opts: []mail.Option{mail.WithPort(123456)},
		},
		AuthStore:    auth.NewMemoryAuth(auth.MemoryAuthConfig{Sliding: true}),
		SessionStore: sessions.NewMemorySessionStore(sessions.MemorySessionStoreConfig{}),
		BeforeStart:  func() { println("do a thing before the app starts") },
		BeforeStop:   func() { println("do a thing before the app stops") },
	})
	defer app.Stop(context.Background())

	// serve routes
	app.GET("/", func(c *sittella.Context[*Queries]) error {
		var data string
		if err := c.Auth().Get(&data); err != nil { // gets the auth cookie if it exists
			fmt.Println(err)
		} else {
			fmt.Println(data) // prints the data mapped to the key in the auth cookie
		}
		return c.String(http.StatusOK, "hello, world!")
	})

	app.GET("/login", func(c *sittella.Context[*Queries]) error {
		// Do some log in logic
		if err := c.Auth().Set("some arbitrary user data"); err != nil { // sets arbitrary data into an auth cookie
			fmt.Println(err)
		}
		return c.Redirect(http.StatusSeeOther, "/")
	})

	app.GET("/logout", func(c *sittella.Context[*Queries]) error {
		// Do some logout logic
		if err := c.Auth().Delete(); err != nil { // revokes the session cookie and deletes the data
			fmt.Println(err)
		}
		return c.Redirect(http.StatusSeeOther, "/")
	})

	// start the app
	if err := app.Start(8000); err != nil {
		panic(err)
	}
}
```

## Usage

### Database

Sittella provides support for any SQL database by using the `database.NewDatabase` constructor.

Sittella also provides specific support for an SQLite3 database with the `sqlitedb.NewSQLiteDB` constructor.
This constructor provides configurability for the database with extensions and the ability to register functionality using [mattn/sqlite3](https://github.com/mattn/go-sqlite3). The Sittella specific SQLite database will automatically have a uuid function registered, meaning it is safe to use `uuid()` in your DDL and queries.

Sittella aims to support more specific databases in the future.

If none of these options suit you, you can create your own implementation of the `database.Database` interface.

Sittella uses goose to make schema migrations `database.Migrate` to supported database specific constructed databases and reserves all migration IDs OVER 9000!!

If using the `database.New`, Sittella will not make any migrations, and you will need to make sure that any schema required by other Sittella functionality is done manually (i.e., db based sessions or auth).

### Mailer

Sittella provides support for basic single and bulk email functionality through the `mailer.DefaultMailer` using [wneessen/go-mail](https://github.com/wneessen/go-mail).

With the dafault mailer, you can:
- Send single or bulk emails
- Include multiple To, CC, and/or BCC recipients
- Include attachments

If the default mailer does not suit your requirements, you can implement your own `mailer.Mailer` interface.

### Auth

Sittella provides support for in memory auth session cookies with database support soon to follow.

The Auth obeject provides the `Set`, `Get`, and `Delete` methods for creating, retrieving, and revoking session cookies. These methods allow for the storage and retrieval of any arbitrary data.

The Auth store is configurable by allowing sliding sessions, cookie settings, setting default expiries and store clearance times, and codecs for encoding data. Additionally, the default time to live for an auth session can optionally be overridden in the `Set` method. The `Get` method also allows ttl overriding if sliding sessions are enabled.

### Sessions

Sittella provides support for a general non-auth session store. This store does not automatically set any cookies.

Similar to the auth store, the session store provides the `Set`, `Get`, and `Delete` methods for loading, retrieving and deleting arbitrary data.

The Session store is configurable by setting default expiries and store clearance times, before set, get, and delete lifecycle hooks, and codecs for encoding data. Additionally, the default time to live for a session can optionally be overridden in the `Set` method.

## Contributing

I'm just a dude that made a framework for myself. If I have done anything dumb or wrong, please do submit a PR with tests and let me know about it!

For documentation, bugs, further testing, submit a PR and I'll merge these if they're appropriate.

For feature requests, please create an issue if one does not exist and I'll look in to it. Alternatively, you can implement it yourself and submit it as a PR and I'll take a look at it.

## License

Standard [MIT](/LICENSE) :)
